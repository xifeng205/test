/*********************************************************************
 * Author        : cuiyunpeng
 * Email         : @163.com
 * Create time   : 2020-12-16 12:48
 * Last modified : 2020-12-16 12:48
 * Filename      : move_averge.cpp
 * Description   :
 *******************************************************************/
// 1. 滑动平均法(moving
// average)又称移动平均法。//
// 意在消除偶然变动因素，找出事物发展趋势，并据此进行预测的方法。
// 滑动平均法是趋势外推技术的一种。实际上是对具有明显的负荷变化趋势的数据序列进行曲线拟合，再用
// 新曲线预报未来的某点处的值。
// 滑动平均法是重在实现“重近轻远”的原则，通过对数据加以小等权，近期数据给予较大权数，远期数据给
// 予较少的权数，目的在于强化近期数据的作用，弱化远期数据的影响
//
// 动态测试数据由确定性成分和随机性成分组成，且前者为所需的测量结果或有效信号，后者即随机起伏的测
// 试误差或噪声，经离散化采样后，可相应地将动态测试数据写成：
// (1)
// 为了更精确地表示测量结果，抑制随机误差{ej}的影响，常对动态测试数据(yj}作平滑和滤波处理。
// 具体地说，就是对非平稳的数据{yj}，在适当的小区间上视为接近平稳的，而作某种局部平均，以减小{ej}
// 所造成的随机起伏。这样沿全长N个数据逐一小区间上进行不断的局部平均，即可得出较平滑的测量结果{fj}，
// 而滤掉频繁起伏的随机误差
// [2]滑动平均法的特点
// 滑动平均法的最主要特点在于简捷性。它相对于其它动态测试数据处理方法而言，算法很简便，计算量较小，
// 尤其可采用递推形式来计算，可节省存贮单元，快速且便于实时处理非平稳数据等，这些是滑动平均法的优点，
// 也是这种古老算法仍有实用价值的主要原因。
// 另一方面，滑动平均法又存在一定的主观性和任意性。因为其应用效果很大程度上取决于各种算法参数的选定
// 。通常依据动态测试过程本身变化的机理，以及实际测试数据的具体变化状态，而靠经验来尽量合理地选定滑
// 动平均算法的参数。
//
// 2. 应用
// (1)
// 用于火炮膛压的测试，滑动平均法在实际生活中可用于测量火炮身管膛内压力随时间变化的过程曲线。
// (2)
// 用于工业现场的控制，通过平滑处理后较好地解决了数据显示不稳及继电器误触发的问题
//
//3. 滑动平均值
//滑动平均值是从一个具有n项时间的序列中来计算多个连续m项序列的平均值

// (1) 计算
//其中连续m项序列的第一项，是原来n序列的第一项至m项之和除以m；连续m项序列的第二项是原来n序列的第
//二项至第m+1项之和除以m；滑动平均值为连续m项序列中的第一项至第m项之和除以……连续m项序列的最后一项
//是原来n序列的第（n-m+1）至第n项之和除以m
//；滑动平均值为连续m项序列中的第一项至第m项之和除以……。
//滑动平均值因项数m的不同而有不同的名称。例如，m为3、5、10，其滑动平均值分别为3年滑动平均值、5年滑
//动平均值和10年滑动平均值。
// 以3年滑动平均值举例：
// 有1、2、3、4、5共5个数，计算过程为：（1+2+3）/3=2，（2+3+4）/3=3，（3+4+5）/3=4，则3年滑动平均值=
// （2+3+4）/3=3。在简单平均数法基础上，通过顺序逐期增减新旧数据求算移动平均值，借以消
//
//4. 总结
//滑动平均值使用"重近轻远"原则, 旨在消除偶变因素, 预测事物的发展趋势,并且实现其老简单.
//
#include <iostream>

using namespace std;
#define size 6000 //数组大小
#define N 12      //滑动平均滤波计算平均值时所取的点数
/*上面两句在使用下面这个函数的时候加到程序的开头*/

template<typename T>
void move_average(T data[]) {
    
}

























// void Smooth(float data[]) {
//   float Sum1 = 0;
//   for (int j = 0; j < size; j++) {
//     if (j < N / 2) {
//       for (int k = 0; k < N; k++) {
//         Sum1 += data[j + k];
//       }
//       data[j] = Sum1 / N;
//     } else if (j < size - N / 2) {
//       for (int k = 0; k < N / 2; k++) {
//         Sum1 += (data[j + k] + data[j - k]);
//       }
//       data[j] = Sum1 / N;
//     } else {
//       for (int k = 0; k < size - j; k++) {
//         Sum1 += data[j + k];
//       }
//       for (int k = 0; k < (N - size + j); k++) {
//         Sum1 += data[j - k];
//       }
//       data[j] = Sum1 / N;
//     }
//     Sum1 = 0;
//   }
// }

int main(int argc, char **argv) { return 0; }
